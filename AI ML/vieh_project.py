# -*- coding: utf-8 -*-
"""VIEH_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qLDt6-eyowkmVxAJcbvQTSVtgTds3CZK

# Breast Cancer Prediction Using ML

**Import Required Libraries**
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns
# %matplotlib inline
import warnings     
warnings.filterwarnings("ignore")
import pickle

"""**Import Dataset**"""

dataset=pd.read_csv("VIEH_BCP_DATASET.csv")
dataset.head()

"""**Data pre-processing & Visualization**"""

dataset=dataset.drop(['id','Unnamed: 32'],axis=1)
dataset.head()

dataset.describe()

dataset.dtypes

dataset.shape

dataset.isnull().sum()

dataset.nunique()

dataset.columns

dataset['diagnosis'].value_counts()

correlation=dataset.corr()
plt.figure(figsize=(25,15))
sns.heatmap(correlation,annot=True)
plt.show()

sns.countplot(dataset['diagnosis'])

x=dataset.drop('diagnosis',axis=1)
x.head()

y=dataset['diagnosis']
y.head()

# find and remove correlated features
def correlation(dataset, threshold):
    col_corr = set()  # Set of all the names of correlated columns
    corr_matrix = dataset.corr()
    for i in range(len(corr_matrix.columns)):
        for j in range(i):
            if abs(corr_matrix.iloc[i, j]) > threshold: # we are interested in absolute coeff value
                colname = corr_matrix.columns[i]  # getting the name of column
                col_corr.add(colname)
    return col_corr

# Setting threshold value if greater than 0.7 means multicollinearity between independent features is high and we have to remove that features:
correlation(dataset, 0.70)

len(correlation(dataset,0.72))

# Listing out highly correlated features:
correlated_features = list(correlation(dataset, 0.72))

# Dropping highly correlated features:
x = x.drop(correlated_features, axis=1)
x.head()

from sklearn.preprocessing import LabelEncoder

encoder=LabelEncoder()

y=encoder.fit_transform(y)
y[:]

x.shape

y.shape

x.columns

"""**Splitting of data**"""

from sklearn.model_selection import train_test_split

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.3,random_state=0)

x_train.shape

y_train.shape

x_test.shape

y_test.shape

"""**Logisitic Regression algorithm**"""

from sklearn.linear_model import LogisticRegression

lr=LogisticRegression()

lr.fit(x_train,y_train)

y_pred=lr.predict(x_test)

#Actual VS Predicted
data=pd.DataFrame({'Actual':y_test,'Predicted':y_pred})
data

"""**Model Evaluation**"""

from sklearn.metrics import accuracy_score,confusion_matrix,classification_report

cm=confusion_matrix(y_test,y_pred)
cm

print('Accuracy score: ',accuracy_score(y_test,y_pred))

print(classification_report(y_test,y_pred))

filename = 'Breast.pkl'
pickle.dump(lr, open(filename, 'wb'))